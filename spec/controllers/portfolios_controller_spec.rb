require 'rails_helper'

# This spec was generated by rspec-rails when you ran the scaffold generator.
# It demonstrates how one might use RSpec to specify the controller code that
# was generated by Rails when you ran the scaffold generator.
#
# It assumes that the implementation code is generated by the rails scaffold
# generator.  If you are using any extension libraries to generate different
# controller code, this generated spec may or may not pass.
#
# It only uses APIs available in rails and/or rspec-rails.  There are a number
# of tools you can use to make these specs even more expressive, but we're
# sticking to rails and rspec-rails APIs to keep things simple and stable.
#
# Compared to earlier versions of this generator, there is very limited use of
# stubs and message expectations in this spec.  Stubs are only used when there
# is no simpler way to get a handle on the object needed for the example.
# Message expectations are only used when there is no simpler way to specify
# that an instance is receiving a specific message.

RSpec.describe PortfoliosController, type: :controller do

  # This should return the minimal set of attributes required to create a valid
  # Group. As you add validations to Group, be sure to
  # adjust the attributes here as well.
  
  let(:valid_user_1_attributes){
    {:email => "eric@eric.com", :password => "Ff123456", :password_confirmation => "Ff123456", :first_name => "Eric", :last_name => "Bechtold", :street => "Michael Street", :city => "Iowa City", :state => "Iowa", :zipcode => "12345", :phone => "1234567890"}
  }
  
  let(:valid_user_2_attributes){
    {:email => "eric2@eric.com", :password => "Ff123456", :password_confirmation => "Ff123456", :first_name => "Eric", :last_name => "Bechtold", :street => "Michael Street", :city => "Iowa City", :state => "Iowa", :zipcode => "12345", :phone => "1234567890"}
  }
  
  let(:valid_user_3_attributes){
    {:email => "eric3@eric.com", :password => "Ff123456", :password_confirmation => "Ff123456", :first_name => "Eric", :last_name => "Bechtold", :street => "Michael Street", :city => "Iowa City", :state => "Iowa", :zipcode => "12345", :phone => "1234567890"}
  }
  
  
  before(:each) do
    
    user1 = User.create valid_user_1_attributes
    group1 = Group.create(:name => "Group 1", :description => "First group created for eric")
    group2 = Group.create(:name => "Group 2", :description => "Second group created for eric")
    user1.groups << group1
    user1.groups << group2
    user1.save
    portfolio1 = Portfolio.create(:name => "Portfolio 1", :description => "First portfolio created for eric")
    portfolio2 = Portfolio.create(:name => "Portfolio 2", :description => "Second portfolio created for eric")
    user1.portfolios << portfolio1
    user1.portfolios << portfolio2
    user1.save
    project1 = Proj.create(:name => "Project 1", :description => "First project created for eric")
    project2 = Proj.create(:name => "Project 2", :description => "Second project created for eric")
    project3 = Proj.create(:name => "Project 3", :description => "Third project created for eric")
    project4 = Proj.create(:name => "Project 4", :description => "Fourth project created for eric")
    user1.projs << project1
    user1.projs << project2
    user1.projs << project3
    user1.projs << project4
    portfolio1.projs << project1
    portfolio1.projs << project2
    portfolio1.projs << project3
    portfolio1.projs << project4
    portfolio2.projs << project1
    portfolio2.projs << project2
    portfolio2.projs << project3
    portfolio2.projs << project4
    portfolio1.groups << group1
    portfolio1.groups << group2
    portfolio2.groups << group1
    portfolio2.groups << group2
    user1.groups[0].projs << project1
    user1.groups[0].projs << project2
    user1.groups[0].projs << project3
    user1.groups[0].projs << project4
    #now assign the visibility.  Portfolio 1 is going to have projects in group 1's visibility off and no projects part of group 2
    tempCss = ProjCss.where(portfolio_id: portfolio1.id, proj_id: project1.id).take
    tempCss.visible = false
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio1.id, proj_id: project2.id).take
    tempCss.visible = false
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio1.id, proj_id: project3.id).take
    tempCss.visible = false
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio1.id, proj_id: project4.id).take
    tempCss.visible = false
    tempCss.save
    # now assign the visiblility.  Portfolio 2 is going to have half the projects' visibility on and no projects part of group 2
    tempCss = ProjCss.where(portfolio_id: portfolio2.id, proj_id: project1.id).take
    tempCss.visible = true
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio2.id, proj_id: project2.id).take
    tempCss.visible = false
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio2.id, proj_id: project3.id).take
    tempCss.visible = true
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio2.id, proj_id: project4.id).take
    tempCss.visible = false
    tempCss.save
    
    ################################################################
    # Now create portfolios for user number 2
    ################################################################
    user2 = User.create valid_user_2_attributes
    group1 = Group.create(:name => "Group 1", :description => "First group created for eric2")
    group2 = Group.create(:name => "Group 2", :description => "Second group created for eric2")
    user2.groups << group1
    user2.groups << group2
    user2.save
    portfolio1 = Portfolio.create(:name => "Portfolio 1", :description => "First portfolio created for eric2")
    portfolio2 = Portfolio.create(:name => "Portfolio 2", :description => "Second portfolio created for eric2")
    user2.portfolios << portfolio1
    user2.portfolios << portfolio2
    user2.save
    project1 = Proj.create(:name => "Project 1", :description => "First project created for eric2")
    project2 = Proj.create(:name => "Project 2", :description => "Second project created for eric2")
    project3 = Proj.create(:name => "Project 3", :description => "Third project created for eric2")
    project4 = Proj.create(:name => "Project 4", :description => "Fourth project created for eric2")
    project5 = Proj.create(:name => "Project 5", :description => "Fifth project created for eric2")
    project6 = Proj.create(:name => "Project 6", :description => "Sixth project created for eric2")
    
    user2.projs << project1
    user2.projs << project2
    user2.projs << project3
    user2.projs << project4
    user2.projs << project5
    user2.projs << project6
    portfolio1.projs << project1
    portfolio1.projs << project2
    portfolio1.projs << project3
    portfolio1.projs << project4
    portfolio1.projs << project5
    portfolio1.projs << project6
    portfolio2.projs << project1
    portfolio2.projs << project2
    portfolio2.projs << project3
    portfolio2.projs << project4
    portfolio2.projs << project5
    portfolio2.projs << project6
    portfolio1.groups << group1
    portfolio1.groups << group2
    portfolio2.groups << group1
    portfolio2.groups << group2
    user2.groups[0].projs << project1
    user2.groups[0].projs << project2
    user2.groups[0].projs << project3
    user2.groups[1].projs << project4
    user2.groups[1].projs << project5
    user2.groups[1].projs << project6
    #now assign the visibility.  Portfolio # 1 is going to have only one project of each group visible
    tempCss = ProjCss.where(portfolio_id: portfolio1.id, proj_id: project1.id).take
    tempCss.visible = true
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio1.id, proj_id: project2.id).take
    tempCss.visible = false
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio1.id, proj_id: project3.id).take
    tempCss.visible = false
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio1.id, proj_id: project4.id).take
    tempCss.visible = false
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio1.id, proj_id: project5.id).take
    tempCss.visible = false
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio1.id, proj_id: project6.id).take
    tempCss.visible = true
    tempCss.save
    # now assign the visiblility.  Portfolio 2 is going to have all projects of all groups visible
    tempCss = ProjCss.where(portfolio_id: portfolio2.id, proj_id: project1.id).take
    tempCss.visible = true
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio2.id, proj_id: project2.id).take
    tempCss.visible = true
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio2.id, proj_id: project3.id).take
    tempCss.visible = true
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio2.id, proj_id: project4.id).take
    tempCss.visible = true
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio2.id, proj_id: project5.id).take
    tempCss.visible = true
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio2.id, proj_id: project6.id).take
    tempCss.visible = true
    tempCss.save
    
        ################################################################
    # Now create portfolios for user number 3
    ################################################################
    user3 = User.create valid_user_3_attributes
    group1 = Group.create(:name => "Group 1", :description => "First group created for eric2")
    group2 = Group.create(:name => "Group 2", :description => "Second group created for eric2")
    user3.groups << group1
    user3.groups << group2
    user3.save
    portfolio1 = Portfolio.create(:name => "Portfolio 1", :description => "First portfolio created for eric2",:token => 'AD35707712')
    portfolio2 = Portfolio.create(:name => "Portfolio 2", :description => "Second portfolio created for eric2", :token => 'EA0C41492B')
    user3.portfolios << portfolio1
    user3.portfolios << portfolio2
    user3.save
    project1 = Proj.create(:name => "Project 1", :description => "First project created for eric2")
    project2 = Proj.create(:name => "Project 2", :description => "Second project created for eric2")
    project3 = Proj.create(:name => "Project 3", :description => "Third project created for eric2")
    project4 = Proj.create(:name => "Project 4", :description => "Fourth project created for eric2")
    project5 = Proj.create(:name => "Project 5", :description => "Fifth project created for eric2")
    project6 = Proj.create(:name => "Project 6", :description => "Sixth project created for eric2")
    user3.projs << project1
    user3.projs << project2
    user3.projs << project3
    user3.projs << project4
    user3.projs << project5
    user3.projs << project6
    portfolio1.projs << project1
    portfolio1.projs << project2
    portfolio1.projs << project3
    portfolio1.projs << project4
    portfolio1.projs << project5
    portfolio1.projs << project6
    portfolio2.projs << project1
    portfolio2.projs << project2
    portfolio2.projs << project3
    portfolio2.projs << project4
    portfolio2.projs << project5
    portfolio2.projs << project6
    portfolio1.groups << group1
    portfolio1.groups << group2
    portfolio2.groups << group1
    portfolio2.groups << group2
    user3.groups[0].projs << project1
    user3.groups[0].projs << project2
    user3.groups[0].projs << project3
    user3.groups[1].projs << project4
    user3.groups[1].projs << project5
    user3.groups[1].projs << project6
    #now assign the visibility.  Portfolio # 1 is going to have only one project of each group visible
    tempCss = ProjCss.where(portfolio_id: portfolio1.id, proj_id: project1.id).take
    tempCss.visible = true
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio1.id, proj_id: project2.id).take
    tempCss.visible = false
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio1.id, proj_id: project3.id).take
    tempCss.visible = false
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio1.id, proj_id: project4.id).take
    tempCss.visible = false
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio1.id, proj_id: project5.id).take
    tempCss.visible = false
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio1.id, proj_id: project6.id).take
    tempCss.visible = true
    tempCss.save
    # now assign the visiblility.  Portfolio 2 is going to have all projects of all groups visible
    tempCss = ProjCss.where(portfolio_id: portfolio2.id, proj_id: project1.id).take
    tempCss.visible = true
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio2.id, proj_id: project2.id).take
    tempCss.visible = true
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio2.id, proj_id: project3.id).take
    tempCss.visible = true
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio2.id, proj_id: project4.id).take
    tempCss.visible = true
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio2.id, proj_id: project5.id).take
    tempCss.visible = true
    tempCss.save
    tempCss = ProjCss.where(portfolio_id: portfolio2.id, proj_id: project6.id).take
    tempCss.visible = true
    tempCss.save
    
  end

  


  describe "GET #index" do
    it "assigns all portfolios for currently logged in user as @portfolios" do
      user1 = User.find_by_email("eric@eric.com")
      sign_in user1
      get :index
      expect(assigns(:portfolios)).to eq(user1.portfolios)
    end
  end
  

  describe "GET #show" do
    it "assigns the groups that have showable projects to @groups -- Special case no groups are shown" do
      user1 = User.find_by_email("eric@eric.com")
      sign_in user1
      portfolio = user1.portfolios.find_by_name("Portfolio 1")
      get :show, {:id => portfolio.id}
      expect(assigns(:groups)).to eq([])
    end
    it "assigns the groups that have showable projects to @groups -- Special case where all groups are shown" do
      user2 = User.find_by_email("eric2@eric.com")
      sign_in user2
      portfolio = user2.portfolios.find_by_name("Portfolio 2")
      group = []
      portfolio.projs.each do |proj|
        if ProjCss.where(proj_id: proj.id, portfolio_id: portfolio.id).take.visible == true && group.include?(proj.group) == false
          group << proj.group
        end
      end
      get :show, {:id => portfolio.id}
      expect(assigns(:groups)).to eq(group)
    end
    it "assigns the groups that have showable projects to @groups -- Special case where one of each group is shown" do
      user2 = User.find_by_email("eric2@eric.com")
      sign_in user2
      portfolio = user2.portfolios.find_by_name("Portfolio 1")
      group = []
      portfolio.projs.each do |proj|
        if ProjCss.where(proj_id: proj.id, portfolio_id: portfolio.id).take.visible == true && group.include?(proj.group) == false
          group << proj.group
        end
      end
      get :show, {:id => portfolio.id}
      expect(assigns(:groups)).to eq(group)
    end
    it "assigns the current portfolio to @portfolio" do
      user2 = User.find_by_email("eric2@eric.com")
      sign_in user2
      portfolio = user2.portfolios.find_by_name("Portfolio 2")
      get :show, {:id => portfolio.id}
      expect(assigns(:portfolio)).to eq(portfolio)
    end
    it "redirects to home page if user not logged in" do
      get :show, {:id => User.find_by_email("eric@eric.com").portfolios[0].id}
      expect(response).to redirect_to("/users/sign_in")
    end
    it "redirects to home page if user is logged in, but attempts to access a portfolio they do not have access to" do
      user1 = User.find_by_email("eric@eric.com")
      user2 = User.find_by_email("eric2@eric.com")
      sign_in user2
      get :show, {:id => user1.portfolios[0].id}
      expect(response).to redirect_to("/")
    end
  end
#
  describe "GET #new" do
    it "assigns all the projects for the current user to @projects" do
      user2 = User.find_by_email("eric2@eric.com")
      sign_in user2
      get :new
      expect(assigns(:projects)).to eq(user2.projs)
    end
    it "assigns all of the groups for the current user to @groups" do
      user2 = User.find_by_email("eric2@eric.com")
      sign_in user2
      get :new
      expect(assigns(:groups)).to eq(user2.groups)
    end
  end
#
  describe "GET #edit" do
    it "assigns all the projects for the current user to @projects" do
      user2 = User.find_by_email("eric2@eric.com")
      sign_in user2
      get :edit, {id: user2.portfolios.find_by_name("Portfolio 2").id}
      expect(assigns(:projects)).to eq(user2.projs)
    end
    it "assigns all of the groups for the current user to @groups" do
      user2 = User.find_by_email("eric2@eric.com")
      sign_in user2
      get :edit, {id: user2.portfolios.find_by_name("Portfolio 2").id}
      expect(assigns(:groups)).to eq(user2.groups)
    end
    it "redirects to home page if user is logged in, but attempts to access a portfolio they do not have access to" do
      user1 = User.find_by_email("eric@eric.com")
      user2 = User.find_by_email("eric2@eric.com")
      sign_in user2
      get :edit, {:id => user1.portfolios[0].id}
      expect(response).to redirect_to("/")
    end
  end

  describe "POST #create" do
    context "with valid params" do
      it "creates a new Portfolio" do
        expect {
          user1 = User.find_by_email("eric@eric.com")
          sign_in user1
          sel_proj1_id = user1.projs.find_by_name("Project 1").id
          sel_proj2_id = user1.projs.find_by_name("Project 2").id
          post :create, {:portfolio => {:name => "Portfolio X", :description => "Portfolio 20", :portfolio_style => ""}, :projects => {"#{sel_proj1_id}" => "1", "#{sel_proj2_id}" => "1"}}
        }.to change(Portfolio, :count).by(1)
      end

      it "assigns a newly created portfolio as @portfolio" do
        user1 = User.find_by_email("eric@eric.com")
        sign_in user1
        sel_proj1_id = user1.projs.find_by_name("Project 1").id
        sel_proj2_id = user1.projs.find_by_name("Project 2").id
        post :create, {:portfolio => {:name => "Portfolio X", :description => "Portfolio 20", :portfolio_style => ""}, :projects => {"#{sel_proj1_id}" => "1", "#{sel_proj2_id}" => "1"}}
        newPortfolio = Portfolio.last
        newPortfolio.projs.each do |proj|
          css_test = ProjCss.where(portfolio_id: newPortfolio.id, proj_id: proj.id).take
          if proj.id == sel_proj1_id || proj.id == sel_proj2_id
            expect(css_test.visible).to eq(true)
          else
            expect(css_test.visible).to eq(false)
          end
        end
        expect(newPortfolio.name).to eq("Portfolio X")
        expect(newPortfolio.description).to eq("Portfolio 20")
        expect(newPortfolio.projs.size).to eq(user1.projs.size)
      end
      
      it "Copies portfolio 1 styling from portfolio 1 to portfolio 2" do
        user1 = User.find_by_email("eric@eric.com")
        sign_in user1
        sel_proj1_id = user1.projs.find_by_name("Project 1").id
        sel_proj2_id = user1.projs.find_by_name("Project 2").id
        portfolio1 = user1.portfolios.find_by_name("Portfolio 1")
        newPortfolio = Portfolio.last
        expect(Portfolio).to receive(:copyCssInfo).with(portfolio1.id, newPortfolio.id+1)   #We tested this function in the test for the Portfolio model so we just need to make sure it was called
        post :create, {:portfolio => {:name => "Portfolio X", :description => "Portfolio 20", :portfolio_style => "Portfolio 1"}, :projects => {"#{sel_proj1_id}" => "1", "#{sel_proj2_id}" => "1"}}
      end

      it "redirects to the portfolio list" do
        user1 = User.find_by_email("eric@eric.com")
        sign_in user1
        sel_proj1_id = user1.projs.find_by_name("Project 1").id
        sel_proj2_id = user1.projs.find_by_name("Project 2").id
        post :create, {:portfolio => {:name => "Portfolio X", :description => "Portfolio 20", :portfolio_style => ""}, :projects => {"#{sel_proj1_id}" => "1", "#{sel_proj2_id}" => "1"}}
        expect(response).to redirect_to('/portfolios')
      end
    end
    context "with invalid params (No portfolio name)" do
      it "displays a flash message with error" do
        user1 = User.find_by_email("eric@eric.com")
        sign_in user1
        sel_proj1_id = user1.projs.find_by_name("Project 1").id
        sel_proj2_id = user1.projs.find_by_name("Project 2").id
        @request.env['HTTP_REFERER'] = 'http://localhost:3000/projs'
        post :create, {:portfolio => {:name => "", :description => "Portfolio 20", :portfolio_style => ""}, :projects => {"#{sel_proj1_id}" => "1", "#{sel_proj2_id}" => "1"}}
        expect(flash[:warning]).to eq('Portfolio name is required. Please try again.')
      end
    end
    
    context "with invalid params (duplicate portfolio name)" do
      it "displays a flash message with error" do
        user1 = User.find_by_email("eric@eric.com")
        sign_in user1
        sel_proj1_id = user1.projs.find_by_name("Project 1").id
        sel_proj2_id = user1.projs.find_by_name("Project 2").id
        @request.env['HTTP_REFERER'] = 'http://localhost:3000/projs'
        post :create, {:portfolio => {:name => "Portfolio 1", :description => "Portfolio 20", :portfolio_style => ""}, :projects => {"#{sel_proj1_id}" => "1", "#{sel_proj2_id}" => "1"}}
        expect(flash[:warning]).to eq('Your Portfolio name must be distinctive.')
      end
    end
  end

  describe "PUT #update" do
    context "with valid params" do
      it "does not create or remove a new portfolio" do
        expect {
          user1 = User.find_by_email("eric@eric.com")
          sign_in user1
          sel_proj1_id = user1.projs.find_by_name("Project 1").id
          sel_proj2_id = user1.projs.find_by_name("Project 2").id
          put :update, {:portfolio => {:name => "Portfolio X", :description => "Portfolio 20", :portfolio_style => ""}, :projects => {"#{sel_proj1_id}" => "1", "#{sel_proj2_id}" => "1"}, :id => user1.portfolios.find_by_name("Portfolio 1").id}
        }.to change(Portfolio, :count).by(0)
      end

      it "assigns a newly created portfolio as @portfolio" do
        user1 = User.find_by_email("eric@eric.com")
        sign_in user1
        sel_proj1_id = user1.projs.find_by_name("Project 2").id
        sel_proj2_id = user1.projs.find_by_name("Project 4").id
        portfolio_id = user1.portfolios.find_by_name("Portfolio 2").id
        put :update, {:portfolio => {:name => "Portfolio X", :description => "Portfolio 20", :portfolio_style => ""}, :projects => {"#{sel_proj1_id}" => "1", "#{sel_proj2_id}" => "1"}, :id => portfolio_id}
        expect(assigns(:portfolio)).to be_a(Portfolio)
        expect(assigns(:portfolio)).to be_persisted
        newPortfolio = Portfolio.find(portfolio_id)
        newPortfolio.projs.each do |proj|
          css_test = ProjCss.where(portfolio_id: newPortfolio.id, proj_id: proj.id).take
          if proj.id == sel_proj1_id || proj.id == sel_proj2_id
            expect(css_test.visible).to eq(true)
          else
            expect(css_test.visible).to eq(false)
          end
        end
        expect(newPortfolio.name).to eq("Portfolio X")
        expect(newPortfolio.description).to eq("Portfolio 20")
        expect(newPortfolio.projs.size).to eq(user1.projs.size)
      end
      
      
      it "Copies portfolio 1 styling from portfolio 1 to portfolio 2 when :portfolio_style is not ''" do
        user1 = User.find_by_email("eric@eric.com")
        sign_in user1
        sel_proj1_id = user1.projs.find_by_name("Project 2").id
        sel_proj2_id = user1.projs.find_by_name("Project 4").id
        portfolio_id = user1.portfolios.find_by_name("Portfolio 2").id
        portfolio_copy_from_id = user1.portfolios.find_by_name("Portfolio 1").id
        expect(Portfolio).to receive(:copyCssInfo).with(portfolio_copy_from_id, portfolio_id)   #We tested this function in the test for the Portfolio model so we just need to make sure it was called
        put :update, {:portfolio => {:name => "Portfolio X", :description => "Portfolio 20", :portfolio_style => "Portfolio 1"}, :projects => {"#{sel_proj1_id}" => "1", "#{sel_proj2_id}" => "1"}, :id => portfolio_id}
      end

      it "redirects to the portfolio list" do
        user1 = User.find_by_email("eric@eric.com")
        sign_in user1
        sel_proj1_id = user1.projs.find_by_name("Project 1").id
        sel_proj2_id = user1.projs.find_by_name("Project 2").id
        put :update, {:portfolio => {:name => "Portfolio X", :description => "Portfolio 20", :portfolio_style => ""}, :projects => {"#{sel_proj1_id}" => "1", "#{sel_proj2_id}" => "1"}, :id => user1.portfolios.find_by_name("Portfolio 1").id}
        expect(response).to redirect_to('/portfolios')
      end
    end
    context "With logged in user attempting to modify a portfolio that is not theirs" do
      it "redirects to the home page" do
        user1 = User.find_by_email("eric@eric.com")
        user2 = User.find_by_email("eric2@eric.com")
        sel_proj1_id = user1.projs.find_by_name("Project 1").id
        sel_proj2_id = user1.projs.find_by_name("Project 2").id
        sign_in user2
        put :update, {:portfolio => {:name => "Portfolio X", :description => "Portfolio 20", :portfolio_style => ""}, :projects => {"#{sel_proj1_id}" => "1", "#{sel_proj2_id}" => "1"}, :id => user1.portfolios.find_by_name("Portfolio 1").id}
        expect(response).to redirect_to("/")
      end
    end
    context "with invalid params (No portfolio name)" do
      it "displays a flash message with error" do
        user1 = User.find_by_email("eric@eric.com")
        sign_in user1
        sel_proj1_id = user1.projs.find_by_name("Project 1").id
        sel_proj2_id = user1.projs.find_by_name("Project 2").id
        @request.env['HTTP_REFERER'] = 'http://localhost:3000/projs'
        put :update, {:portfolio => {:name => "", :description => "Portfolio 20", :portfolio_style => ""}, :projects => {"#{sel_proj1_id}" => "1", "#{sel_proj2_id}" => "1"}, :id => user1.portfolios.find_by_name("Portfolio 1").id}
        expect(flash[:warning]).to eq('Portfolio name is required. Please try again.')
      end
    end
    
    context "with invalid params (duplicate portfolio name)" do
      it "displays a flash message with error" do
        user1 = User.find_by_email("eric@eric.com")
        sign_in user1
        sel_proj1_id = user1.projs.find_by_name("Project 1").id
        sel_proj2_id = user1.projs.find_by_name("Project 2").id
        @request.env['HTTP_REFERER'] = 'http://localhost:3000/projs'
        put :update, {:portfolio => {:name => "Portfolio 2", :description => "Portfolio 20", :portfolio_style => ""}, :projects => {"#{sel_proj1_id}" => "1", "#{sel_proj2_id}" => "1"}, :id => user1.portfolios.find_by_name("Portfolio 1").id}
        expect(flash[:warning]).to eq('Your Portfolio name must be distinctive.')
      end
    end
      
  end

  describe "DELETE #destroy" do
    it "destroys the requested portfolio" do
      user1 = User.find_by_email("eric@eric.com")
      sign_in user1
      delete_portfolio_id = user1.portfolios[0].id
      expect {
        delete :destroy, {:id => delete_portfolio_id}
      }.to change(Portfolio, :count).by(-1)
      temp = user1.portfolios.find_by_id(delete_portfolio_id)
      expect(temp).to eq(nil)
    end

    it "redirects to the portfolios list" do
      user1 = User.find_by_email("eric@eric.com")
      sign_in user1
      delete_portfolio_id = user1.portfolios[0].id
      delete :destroy, {:id => delete_portfolio_id}
      expect(response).to redirect_to('/portfolios')
    end
    
    it "redirects to the home page if the error was not displayed" do
      expect {
        user1 = User.find_by_email("eric@eric.com")
        user2 = User.find_by_email("eric2@eric.com")
        sign_in user2
        delete_portfolio_id = user1.portfolios[0].id
        delete :destroy, {:id => delete_portfolio_id}
      }.to change(Portfolio, :count).by(0)
      expect(response).to redirect_to('/')
    end
  end
  
  describe "GET # generateLink" do
    it "should generate a link for sharing to people without an account" do 
      user3 = User.find_by_email("eric3@eric.com")

      sign_in user3
      portfolio1 = user3.portfolios[0]  #We are going to use Portfolio 2, group 1 because half of its projects are not visible
      get :generateLink, {:token => portfolio1.token}
      expect(assigns(:portfolio)).to eq(portfolio1)
      get :generateLink, {:token => portfolio1.id}
      expect(assigns(:portfolio)).to eq(portfolio1)
    end
    it "won't be able to view by a user that doesn't have the portfolio" do
      user3 = User.find_by_email("eric3@eric.com")
      sign_in user3
      portfolio1 = user3.portfolios[0]  #We are going to use Portfolio 2, group 1 because half of its projects are not visible
      sign_out user3
      user2 = User.find_by_email("eric2@eric.com")
      sign_in user2
      get :generateLink, {:token => portfolio1.token}
      expect(response).to redirect_to('/portfolios')
    end
    
  end
end